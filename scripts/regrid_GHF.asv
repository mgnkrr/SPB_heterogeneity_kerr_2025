%%% Process GHF Models (auto-CRS, unit-aware, orientation-safe) %%%
% UPDATED: Adds Colgan unitless topographic correction (Delta = dG/G) from a .nc,
%          applies G_corr = G*(1+Delta) to every interpolated GHF map,
%          and reports ROI stats for "how much is changed".
%
% NOTE: Set `colgan_nc` path below. Everything else should run without losing
%       any existing functionality.

clearvars; close all;

%% ------------------ Toggles ------------------
doModels = struct( ...
    'Stal',     true, ...
    'Hazzard',  true, ...
    'An',       true, ...
    'FoxMaule', true, ...
    'Martos',   true, ...
    'Shen',     true, ...
    'Losing',   true, ...
    'Haeger',   true, ...   
    'Lucazeau', true, ...
    'save',     true ...
);

%% ------------------ Topographic correction (Colgan .nc; unitless) ------------------
doTopo = true;  % master switch for applying Colgan correction

% Path to Colgan NetCDF that contains Delta = dG/G (unitless) and x/y (or lon/lat)
% >>> SET THIS <<<
colgan_nc = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/for_pub/datasets/colgan_topo_ghf.nc';

% Optional ROI mask (logical array same size as Xgrid/Ygrid)
% Leave empty to compute stats over all finite grid cells.
roiMask = [];           % if you already have it in workspace, set it here
roi_mask_src = '';      % e.g., 'datasets_for_gmin/ISPB_mask.mat'
roi_mask_var = 'roiMask';

% Save correction products / stats
saveTopoProducts = true;
topo_stats_out = fullfile('/disk/kea/WAIS/home/wais/users/mek/gmin_code/for_pub/datasets','topo_correction_stats.mat');
topo_stats_csv = fullfile('/disk/kea/WAIS/home/wais/users/mek/gmin_code/for_pub/datasets','topo_correction_stats.csv');

%% ------------------ Target grid (EPSG:3031) ------------------
tgrid = load('/disk/kea/WAIS/home/wais/users/mek/gmin_code/for_pub/datasets/coldex_icethk.mat','Xgrid','Ygrid');
Xgrid = tgrid.Xgrid;
Ygrid = tgrid.Ygrid;     % meters, EPSG:3031
proj  = projcrs(3031);

qa_outdir = fullfile('/disk/kea/WAIS/home/wais/users/mek/gmin_code/for_pub/datasets','qa_maps');
if ~exist(qa_outdir,'dir'), mkdir(qa_outdir); end

%% ------------------ Helpers ------------------
function Zs = ensure_grid_shape(Z, xv, yv)
    % Try to coerce Z to [numel(yv) x numel(xv)], otherwise return Z unchanged.
    ny = numel(yv); nx = numel(xv);
    [zy, zx] = size(Z);

    if zy == ny && zx == nx
        Zs = Z; return;
    end
    if zy == nx && zx == ny
        Zs = Z.'; return;  % pure transpose solves it
    end

    % If neither matches exactly, clip to the common extents safely.
    cy = min(zy, ny); cx = min(zx, nx);
    warning('ensure_grid_shape: size mismatch (Z=%dx%d vs axes=%dx%d). Clipping to %dx%d.', ...
        zy, zx, ny, nx, cy, cx);
    Zs = Z(1:cy, 1:cx);
end

function z = to_mW_if_W(filename, varname, z)
    u = '';
    try u = ncreadatt(filename, varname, 'units'); catch, end
    s = lower(string(u));
    if contains(s,'w') && ~contains(s,'mw')
        z = z * 1000;  % W/m^2 -> mW/m^2
        fprintf('[units] %s:%s converted W->mW\n', filename, varname);
    else
        fprintf('[units] %s:%s assumed mW\n', filename, varname);
    end
end

function A = clean_grid(A, file, varname)
    fv = []; mv = [];
    try fv = ncreadatt(file, varname, '_FillValue');    catch, end
    try mv = ncreadatt(file, varname, 'missing_value'); catch, end
    bad = [];
    if isnumeric(fv), bad = [bad; fv(:)]; end
    if isnumeric(mv), bad = [bad; mv(:)]; end
    bad = bad(isfinite(bad));
    M = ~isfinite(A);
    if ~isempty(bad), M = M | ismember(A, bad); end
    A(M) = NaN;
end

% ---------- AUTO CRS / UNITS DETECTION ----------
function [mode, ux, uy] = detect_axis_mode(file, xname, yname, xv, yv)
% mode ∈ {'degrees','meters','kilometers','unknown'}
    ux=''; uy='';
    try ux = lower(string(ncreadatt(file, xname, 'units'))); catch, end
    try uy = lower(string(ncreadatt(file, yname, 'units'))); catch, end
    % CF-Convention hints
    sx=''; sy='';
    try sx = lower(string(ncreadatt(file, xname, 'standard_name'))); catch, end
    try sy = lower(string(ncreadatt(file, yname, 'standard_name'))); catch, end
    xn = lower(string(xname)); yn = lower(string(yname));

    % 1) Attribute / name based
    if contains(ux,'degree') || contains(uy,'degree') || ...
       contains(sx,'longitude') || contains(sy,'latitude') || ...
       ismember(xn,["lon","longitude"]) || ismember(yn,["lat","latitude"])
        mode = 'degrees'; return;
    end
    if contains(ux,'kilometer') || contains(ux,'km') || contains(uy,'kilometer') || contains(uy,'km')
        mode = 'kilometers'; return;
    end
    if contains(ux,'metre') || contains(ux,'meter') || contains(uy,'metre') || contains(uy,'meter')
        mode = 'meters'; return;
    end

    % 2) Numeric heuristics (robust)
    ax = max(abs(xv)); ay = max(abs(yv));
    if ax <= 370 && ay <= 95
        mode = 'degrees'; return;
    end
    if ax > 5e3 || ay > 5e3
        mode = 'meters'; return;
    end

    % 3) Spacing heuristic
    dx = median(abs(diff(xv))); dy = median(abs(diff(yv)));
    if dx < 5 && dy < 5 && ax <= 720 && ay <= 180
        mode = 'degrees';
    else
        mode = 'meters';
    end
end

function [xv_m, yv_m, decided] = normalize_axes_units(file, xname, yname, xv, yv)
    [mode, ux, uy] = detect_axis_mode(file, xname, yname, xv, yv);
    decided = mode;
    switch mode
        case 'degrees'
            xv_m = xv; yv_m = yv;  % degrees for now (project later)
        case 'kilometers'
            xv_m = xv * 1000; yv_m = yv * 1000;
            fprintf('[axes] %s:(%s,%s) km->m\n', file, xname, yname);
        otherwise % meters or unknown->assume meters
            xv_m = xv; yv_m = yv;
    end
    fprintf('[axes] %s:(%s,%s) detected=%s (ux="%s", uy="%s")\n', ...
        file, xname, yname, string(decided), string(ux), string(uy));
end

function [Xps, Yps, decided] = to3031_auto(file, xname, yname, xv, yv, proj)
    [xv_n, yv_n, decided] = normalize_axes_units(file, xname, yname, xv, yv);
    if strcmpi(decided,'degrees')
        [Xps, Yps] = to3031(xv_n, yv_n, true, proj);
    else
        [Xps, Yps] = to3031(xv_n, yv_n, false, proj);
    end
end
% ------------------------------------------------

function [xps,yps] = to3031(xv, yv, assume_deg, proj)
    if assume_deg
        [lon, lat] = meshgrid(xv, yv);
        [xps, yps] = projfwd(proj, lat, lon);
    else
        [xps, yps] = meshgrid(xv, yv);
    end
end

function [F, kept, frac, nfin] = make_interpolant(x, y, z)
    % Ensure column vectors
    x = x(:); y = y(:); z = z(:);

    % Keep only finite triplets
    Mfin = isfinite(x) & isfinite(y) & isfinite(z);
    x = x(Mfin); y = y(Mfin); z = z(Mfin);
    nfin = numel(x);

    if nfin==0
        warning('No finite points for interpolant. Returning empty.');
        F = []; kept = 0; frac = 0; return;
    end

    % Force DOUBLE for scatteredInterpolant (required)
    x = double(x);
    y = double(y);
    z = double(z);

    % Remove duplicate xy locations
    [xyu, ia] = unique([x y], 'rows', 'stable');

    % Build interpolant
    F = scatteredInterpolant(xyu(:,1), xyu(:,2), z(ia), 'linear', 'none');

    kept = numel(ia);
    frac = kept / nfin;
end

function qa_map(Z, Xgrid, Ygrid, titleStr, out_png)
    figure('Color','w');
    imagesc([min(Xgrid(1,:)) max(Xgrid(1,:))], [min(Ygrid(:,1)) max(Ygrid(:,1))], Z);
    set(gca,'YDir','normal','DataAspectRatio',[1 1 1]); colorbar;
    title(sprintf('%s\n[min=%.3g max=%.3g finite=%d/%d]', titleStr, ...
          min(Z(:),[],'omitnan'), max(Z(:),[],'omitnan'), nnz(isfinite(Z)), numel(Z)));
    xlabel('X (m, EPSG:3031)'); ylabel('Y (m, EPSG:3031)');
    try exportgraphics(gcf, out_png, 'Resolution', 180); catch, end
    close all;
end

function qa_hist(Z, titleStr, out_png)
    z = Z(isfinite(Z));
    figure('Color','w'); histogram(z, 100);
    title(sprintf('%s — histogram (n=%d)', titleStr, numel(z)));
    xlabel('value'); ylabel('count');
    try exportgraphics(gcf, out_png, 'Resolution', 180); catch, end
    close all;
end

function coverage_check(name, xps, yps, Xgrid, Ygrid)
    in = xps(:)>=min(Xgrid(1,:)) & xps(:)<=max(Xgrid(1,:)) & ...
         yps(:)>=min(Ygrid(:,1)) & yps(:)<=max(Ygrid(:,1));
    fprintf('[cover] %s: points inside target bbox = %d/%d (%.1f%%)\n', ...
        name, nnz(in), numel(in), 100*nnz(in)/numel(in));
end

% Source-map helpers
function qa_map_rect_source(xv, yv, Z, assume_deg, proj, titleStr, out_png)
    % Coerce size
    Zc = ensure_grid_shape(Z, xv, yv);
    ny = size(Zc,1); nx = size(Zc,2);

    % Trim axes
    xv = xv(:).'; yv = yv(:).';
    if numel(xv) ~= nx, xv = xv(1:nx); end
    if numel(yv) ~= ny, yv = yv(1:ny); end

    % Orientation / flips
    flipNotes = {};
    if xv(1) > xv(end)
        xv = fliplr(xv); Zc = fliplr(Zc);
        flipNotes{end+1} = 'flipped X';
    end
    if yv(1) > yv(end)
        yv = fliplr(yv); Zc = flipud(Zc);
        flipNotes{end+1} = 'flipped Y';
    end
    flipNoteStr = '';
    if ~isempty(flipNotes)
        flipNoteStr = [' (' strjoin(flipNotes, ', ') ')'];
    end

    % Downsample
    maxN = 1200;
    ix = round(linspace(1,nx,min(nx,maxN)));
    iy = round(linspace(1,ny,min(ny,maxN)));
    xv2 = xv(ix); yv2 = yv(iy); Z2 = Zc(iy,ix);

    % Project to EPSG:3031
    [xps,yps] = to3031(xv2, yv2, assume_deg, proj);

    % Plot
    figure('Color','w');
    imagesc([min(xps(:)) max(xps(:))],[min(yps(:)) max(yps(:))],Z2);
    set(gca,'YDir','normal','DataAspectRatio',[1 1 1]); colorbar;
    title(sprintf('%s (SOURCE → EPSG:3031)%s\n[min=%.3g max=%.3g finite=%d/%d]', ...
        titleStr, flipNoteStr, ...
        min(Z(:),[],'omitnan'), max(Z(:),[],'omitnan'), ...
        nnz(isfinite(Z)), numel(Z)));
    xlabel('X (m)'); ylabel('Y (m)');
    try exportgraphics(gcf,out_png,'Resolution',180); catch, end
    close all;
end

function qa_map_scatter_source(x, y, z, assume_deg, proj, titleStr, out_png)
    Mfin = isfinite(x) & isfinite(y) & isfinite(z);
    x = x(Mfin); y = y(Mfin); z = z(Mfin);
    N = numel(x); maxN = 250000;
    if N > maxN, sel = randperm(N, maxN); x = x(sel); y = y(sel); z = z(sel); end
    if assume_deg, [xps, yps] = projfwd(proj, y, x); else, xps = x; yps = y; end
    figure('Color','w'); scatter(xps, yps, 6, z, 'filled'); axis equal tight; colorbar;
    title(sprintf('%s (SOURCE native → EPSG:3031)\n[min=%.3g max=%.3g finite=%d]', ...
        titleStr, min(z,[],'omitnan'), max(z,[],'omitnan'), numel(z)));
    xlabel('X (m)'); ylabel('Y (m)');
    try exportgraphics(gcf, out_png, 'Resolution', 220); catch, end
    close all;
end

function [Delta_topo, used] = load_colgan_delta_to_target(colgan_nc, proj, Xgrid, Ygrid, qa_outdir)
    % Load unitless Delta = dG/G from Colgan netCDF, project/regrid to target grid.
    % Robustly guesses variable + axes names.

    if ~isfile(colgan_nc)
        error('Colgan nc file not found: %s', colgan_nc);
    end

    info = ncinfo(colgan_nc);
    varnames = string({info.Variables.Name});

    % ---- choose correction var (unitless) ----
    cand = ["delta","Delta","dG_over_G","dG_G","topo_correction","correction","anomaly","ghf_anomaly"];
    vname = "";
    for k = 1:numel(cand)
        hit = strcmpi(varnames, cand(k));
        if any(hit)
            vname = varnames(hit); vname = vname(1);
            break;
        end
    end
    if vname == ""
        % fallback: pick first non-coordinate >=2D var
        isCoord = ismember(lower(varnames), ["x","y","lon","longitude","lat","latitude","time"]);
        dataVars = varnames(~isCoord);
        for k = 1:numel(dataVars)
            vv = info.Variables(strcmp(varnames, dataVars(k)));
            if numel(vv.Size) >= 2
                vname = dataVars(k);
                break;
            end
        end
        if vname == ""
            error('Could not find a suitable correction variable in %s', colgan_nc);
        end
    end

    % ---- axes ----
    xname = ""; yname = "";
    xCand = ["x","X","lon","longitude"];
    yCand = ["y","Y","lat","latitude"];
    for k = 1:numel(xCand)
        hit = strcmpi(varnames, xCand(k));
        if any(hit), xname = varnames(hit); xname = xname(1); break; end
    end
    for k = 1:numel(yCand)
        hit = strcmpi(varnames, yCand(k));
        if any(hit), yname = varnames(hit); yname = yname(1); break; end
    end
    if xname=="" || yname==""
        error('Could not find coordinate variables (x/y or lon/lat) in %s', colgan_nc);
    end

    fprintf('[Colgan] using var=%s, x=%s, y=%s\n', vname, xname, yname);

    Delta_src = ncread(colgan_nc, char(vname));
    Delta_src = clean_grid(Delta_src, colgan_nc, char(vname));

    xv = ncread(colgan_nc, char(xname));
    yv = ncread(colgan_nc, char(yname));

    % coerce shape to [ny x nx]
    Delta_src = ensure_grid_shape(Delta_src, xv, yv);

    % ensure increasing axes (and flip Z accordingly)
    xv = xv(:).'; yv = yv(:);
    if xv(1) > xv(end), xv = fliplr(xv); Delta_src = fliplr(Delta_src); end
    if yv(1) > yv(end), yv = flipud(yv); Delta_src = flipud(Delta_src); end

    % project/normalize axes to 3031
    [Xps, Yps, decided] = to3031_auto(colgan_nc, char(xname), char(yname), xv, yv, proj);

    % interpolant
    [F_D, keptD, fracD, nfinD] = make_interpolant(Xps(:), Yps(:), Delta_src(:));
    fprintf('[Colgan] interpolant kept=%d/%.1f%% finite=%d (axes=%s)\n', keptD, 100*fracD, nfinD, decided);

    Delta_topo = F_D(Xgrid, Ygrid);

    % QA
    qa_map(Delta_topo, Xgrid, Ygrid, 'Colgan \Delta topo (unitless) on target grid', fullfile(qa_outdir,'map_Delta_Colgan.png'));
    qa_hist(Delta_topo, 'Colgan \Delta topo (unitless)', fullfile(qa_outdir,'hist_Delta_Colgan.png'));

    used = struct('vname',vname,'xname',xname,'yname',yname,'axes_mode',decided,'kept',keptD,'frac',fracD,'nfin',nfinD);
end

function S = topo_change_stats(G0, Gc, roiMask, name)
    if nargin < 3 || isempty(roiMask)
        roiMask = true(size(G0));
    end
    M = roiMask & isfinite(G0) & isfinite(Gc) & (G0~=0);

    dAbs  = (Gc - G0);
    dFrac = dAbs ./ G0;        % unitless
    dPct  = 100*dFrac;         % percent

    S = struct();
    S.name = string(name);
    S.n = nnz(M);

    S.abs_mean   = mean(dAbs(M), 'omitnan');
    S.abs_median = median(dAbs(M), 'omitnan');
    S.abs_std    = std(dAbs(M), 0, 'omitnan');
    S.abs_p05    = prctile(dAbs(M), 5);
    S.abs_p95    = prctile(dAbs(M), 95);

    S.pct_mean   = mean(dPct(M), 'omitnan');
    S.pct_median = median(dPct(M), 'omitnan');
    S.pct_std    = std(dPct(M), 0, 'omitnan');
    S.pct_p05    = prctile(dPct(M), 5);
    S.pct_p95    = prctile(dPct(M), 95);

    S.frac_gt_05 = mean(abs(dFrac(M)) > 0.05);
    S.frac_gt_10 = mean(abs(dFrac(M)) > 0.10);
    S.frac_gt_25 = mean(abs(dFrac(M)) > 0.25);
end

%% ------------------ Load ROI mask if provided ------------------
if isempty(roiMask) && ~isempty(roi_mask_src)
    R = load(roi_mask_src);
    if isfield(R, roi_mask_var)
        roiMask = logical(R.(roi_mask_var));
        fprintf('[ROI] loaded %s from %s\n', roi_mask_var, roi_mask_src);
    else
        error('ROI mask var "%s" not found in %s.', roi_mask_var, roi_mask_src);
    end
end

%% ------------------ Load Colgan correction onto target grid ------------------
Delta_topo = [];
colgan_used = struct();
if doTopo
    [Delta_topo, colgan_used] = load_colgan_delta_to_target(colgan_nc, proj, Xgrid, Ygrid, qa_outdir);

    if isempty(roiMask)
        roiMask = isfinite(Delta_topo);
        fprintf('[ROI] default ROI = all finite Delta cells (n=%d)\n', nnz(roiMask));
    end
end

% stats collector
topoStats = struct('name',{},'n',{}, ...
    'abs_mean',{},'abs_median',{},'abs_std',{},'abs_p05',{},'abs_p95',{}, ...
    'pct_mean',{},'pct_median',{},'pct_std',{},'pct_p05',{},'pct_p95',{}, ...
    'frac_gt_05',{},'frac_gt_10',{},'frac_gt_25',{});

%% ------------------ Stål (EPSG:3031; Q,U in W m^-2) ------------------
if doModels.Stal
    stal_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/aq1_01_20.nc';
    HF_stal   = ncread(stal_file,'Q');        % W/m^2
    UNC_stal  = ncread(stal_file,'U');        % W/m^2 (σ)
    x_stal    = ncread(stal_file,'X');        % meters (EPSG:3031)
    y_stal    = ncread(stal_file,'Y');

    HF_stal  = HF_stal * 1000;
    HF_stal = flipud(HF_stal);
    HF_stal = rot90(HF_stal, -1);

    UNC_stal = UNC_stal * 1000;
    UNC_stal = flipud(UNC_stal);
    UNC_stal = rot90(UNC_stal, -1);

    % Auto-detect axes (should be meters)
    [XS_stal, YS_stal, decided_stal] = to3031_auto(stal_file, 'X', 'Y', x_stal, y_stal, proj);
    qa_map_rect_source(x_stal, y_stal, HF_stal, strcmp(decided_stal,'degrees'), proj, ...
        'GHF Stal (SOURCE)', fullfile(qa_outdir,'SRC_GHF_Stal.png'));
    qa_map_rect_source(x_stal, y_stal, UNC_stal, strcmp(decided_stal,'degrees'), proj, ...
        'UNC Stal σ (SOURCE)', fullfile(qa_outdir,'SRC_UNC_Stal.png'));

    [F_stal, keptS, fracS, nfinS]   = make_interpolant(XS_stal(:), YS_stal(:), HF_stal(:));
    [U_stal, keptSU, fracSU, nfinSU]= make_interpolant(XS_stal(:), YS_stal(:), UNC_stal(:));
    fprintf('[Stal] mean kept=%d/%.0f%% finite=%d | unc kept=%d/%.0f%% finite=%d\n', ...
        keptS, 100*fracS, nfinS, keptSU, 100*fracSU, nfinSU);
    coverage_check('Stal', XS_stal, YS_stal, Xgrid, Ygrid);

    GHF_Stal_interp = F_stal(Xgrid, Ygrid);
    UNC_Stal_interp = U_stal(Xgrid, Ygrid);
    qa_map(GHF_Stal_interp, Xgrid, Ygrid, 'GHF Stal (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Stal.png'));
    qa_hist(GHF_Stal_interp, 'GHF Stal', fullfile(qa_outdir,'hist_GHF_Stal.png'));
    qa_map(UNC_Stal_interp, Xgrid, Ygrid, 'UNC Stal (σ, mW m^{-2})', fullfile(qa_outdir,'map_UNC_Stal.png'));
    qa_hist(UNC_Stal_interp, 'UNC Stal (σ)', fullfile(qa_outdir,'hist_UNC_Stal.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Stal_interp_corr = GHF_Stal_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Stal_interp, GHF_Stal_interp_corr, roiMask, 'Stal'); 
        qa_map(GHF_Stal_interp_corr - GHF_Stal_interp, Xgrid, Ygrid, 'Stal: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Stal_dAbs.png'));
        qa_map(100*(GHF_Stal_interp_corr - GHF_Stal_interp)./GHF_Stal_interp, Xgrid, Ygrid, 'Stal: percent change (%)', fullfile(qa_outdir,'map_Stal_dPct.png'));
    end
end

%% ------------------ Hazzard mean ------------------
if doModels.Hazzard
    haz_mean_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/HR24_GHF_mean_PS.grd';
    HF_haz = ncread(haz_mean_file,'z');
    x_haz = ncread(haz_mean_file,'x');
    y_haz = ncread(haz_mean_file,'y');

    HF_haz = to_mW_if_W(haz_mean_file,'z',HF_haz);
    HF_haz = clean_grid(HF_haz, haz_mean_file, 'z');
    HF_haz = flipud(HF_haz);
    HF_haz = rot90(HF_haz, -1);

    [x_hazg, y_hazg] = meshgrid(x_haz*1000, y_haz*1000);

    [F_haz, ~, ~] = make_interpolant(x_hazg(:), y_hazg(:), HF_haz(:));
    GHF_Hazzard_interp = F_haz(Xgrid, Ygrid);

    % === Std: already EPSG:3031 (km) ===
    haz_std_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/HR24_GHF_std_PS.grd';
    SD_haz = ncread(haz_std_file,'z');

    SD_haz = flipud(SD_haz);
    SD_haz = rot90(SD_haz, -1);

    x_haz2 = ncread(haz_std_file,'x');   % km
    y_haz2 = ncread(haz_std_file,'y');   % km

    [x_haz2g, y_haz2g] = meshgrid(x_haz2*1000, y_haz2*1000);

    SD_haz = to_mW_if_W(haz_std_file,'z',SD_haz);
    SD_haz = clean_grid(SD_haz, haz_std_file, 'z');

    [F_haz_std, kept_std, frac_std] = make_interpolant(x_haz2g(:), y_haz2g(:), SD_haz(:));
    UNC_Hazzard_interp = F_haz_std(Xgrid, Ygrid);

    fprintf('[Hazzard] mean=lat/lon projected, std=EPSG:3031 (km->m), kept=%d (%.2f%%)\n', ...
        kept_std, 100*frac_std);

    qa_map(GHF_Hazzard_interp, Xgrid, Ygrid, 'GHF Hazzard (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Hazzard.png'));
    qa_hist(GHF_Hazzard_interp, 'GHF Hazzard', fullfile(qa_outdir,'hist_GHF_Hazzard.png'));
    qa_map(UNC_Hazzard_interp, Xgrid, Ygrid, 'UNC Hazzard (σ, mW m^{-2})', fullfile(qa_outdir,'map_UNC_Hazzard.png'));
    qa_hist(UNC_Hazzard_interp, 'UNC Hazzard (σ)', fullfile(qa_outdir,'hist_UNC_Hazzard.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Hazzard_interp_corr = GHF_Hazzard_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Hazzard_interp, GHF_Hazzard_interp_corr, roiMask, 'Hazzard'); 
        qa_map(GHF_Hazzard_interp_corr - GHF_Hazzard_interp, Xgrid, Ygrid, 'Hazzard: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Hazzard_dAbs.png'));
        qa_map(100*(GHF_Hazzard_interp_corr - GHF_Hazzard_interp)./GHF_Hazzard_interp, Xgrid, Ygrid, 'Hazzard: percent change (%)', fullfile(qa_outdir,'map_Hazzard_dPct.png'));
    end
end

%% ------------------ An ------------------
if doModels.An
    an_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/AN1-HF.grd';
    HF_an = ncread(an_file,'z');
    x_an  = ncread(an_file,'lon'); y_an = ncread(an_file,'lat');
    HF_an = to_mW_if_W(an_file,'z',HF_an);

    % Fix orientation if dimensions don't match
    if size(HF_an,1) == numel(x_an) && size(HF_an,2) == numel(y_an)
        HF_an = HF_an.';  % transpose
    end

    if y_an(1) > y_an(end)
        y_an = flipud(y_an);
        HF_an = flipud(HF_an);
    end

    [lon_an, lat_an] = meshgrid(x_an, y_an);

    [Xps_an, Yps_an] = projfwd(proj, lat_an, lon_an);

    [F_an, ~, ~] = make_interpolant(Xps_an(:), Yps_an(:), HF_an(:));
    GHF_An_interp = F_an(Xgrid, Ygrid);

    qa_map(GHF_An_interp, Xgrid, Ygrid, 'GHF An (mW m^{-2})', fullfile(qa_outdir,'map_GHF_An.png'));
    qa_hist(GHF_An_interp, 'GHF An', fullfile(qa_outdir,'hist_GHF_An.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_An_interp_corr = GHF_An_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_An_interp, GHF_An_interp_corr, roiMask, 'An'); 
        qa_map(GHF_An_interp_corr - GHF_An_interp, Xgrid, Ygrid, 'An: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_An_dAbs.png'));
        qa_map(100*(GHF_An_interp_corr - GHF_An_interp)./GHF_An_interp, Xgrid, Ygrid, 'An: percent change (%)', fullfile(qa_outdir,'map_An_dPct.png'));
    end
end

%% ------------------ Fox Maule ------------------
if doModels.FoxMaule
    fox_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/fox_maule-hfmag.grd';
    HF_fox = ncread(fox_file,'z');
    x_fox  = ncread(fox_file,'x'); y_fox = ncread(fox_file,'y');
    HF_fox = to_mW_if_W(fox_file,'z',HF_fox);

    HF_fox = flipud(HF_fox);
    HF_fox = rot90(HF_fox, -1);

    [X_fox_ps, Y_fox_ps, decided_fox] = to3031_auto(fox_file, 'x','y', x_fox, y_fox, proj);
    qa_map_rect_source(x_fox, y_fox, HF_fox, strcmp(decided_fox,'degrees'), proj, ...
        'GHF FoxMaule (SOURCE)', fullfile(qa_outdir,'SRC_GHF_FoxMaule.png'));

    [F_fox, keptF, fracF, nfinF] = make_interpolant(X_fox_ps(:), Y_fox_ps(:), HF_fox(:));
    fprintf('[FoxMaule] kept=%d/%.0f%% finite=%d (axes=%s)\n', keptF, 100*fracF, nfinF, decided_fox);
    coverage_check('FoxMaule', X_fox_ps, Y_fox_ps, Xgrid, Ygrid);

    GHF_FoxMaule_interp = F_fox(Xgrid, Ygrid);
    qa_map(GHF_FoxMaule_interp, Xgrid, Ygrid, 'GHF FoxMaule (mW m^{-2})', fullfile(qa_outdir,'map_GHF_FoxMaule.png'));
    qa_hist(GHF_FoxMaule_interp, 'GHF FoxMaule', fullfile(qa_outdir,'hist_GHF_FoxMaule.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_FoxMaule_interp_corr = GHF_FoxMaule_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_FoxMaule_interp, GHF_FoxMaule_interp_corr, roiMask, 'FoxMaule'); 
        qa_map(GHF_FoxMaule_interp_corr - GHF_FoxMaule_interp, Xgrid, Ygrid, 'FoxMaule: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_FoxMaule_dAbs.png'));
        qa_map(100*(GHF_FoxMaule_interp_corr - GHF_FoxMaule_interp)./GHF_FoxMaule_interp, Xgrid, Ygrid, 'FoxMaule: percent change (%)', fullfile(qa_outdir,'map_FoxMaule_dPct.png'));
    end
end

%% ------------------ Martos (XYZ, EPSG:3031 assumed) ------------------
if doModels.Martos
    martos = readmatrix('/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/Martos_GHF.xyz', 'FileType', 'text');
    xm = martos(:,1); ym = martos(:,2); zm = martos(:,3);
    qa_map_scatter_source(xm, ym, zm, false, proj, 'GHF Martos (SOURCE)', fullfile(qa_outdir,'SRC_GHF_Martos.png'));
    [F_martos, keptM, fracM, nfinM] = make_interpolant(xm, ym, zm);
    fprintf('[Martos] kept=%d/%.0f%% finite=%d\n', keptM, 100*fracM, nfinM);
    coverage_check('Martos mean', xm, ym, Xgrid, Ygrid);

    GHF_Martos_interp = F_martos(Xgrid, Ygrid);
    qa_map(GHF_Martos_interp, Xgrid, Ygrid, 'GHF Martos (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Martos.png'));
    qa_hist(GHF_Martos_interp, 'GHF Martos', fullfile(qa_outdir,'hist_GHF_Martos.png'));

    martos_unc = readmatrix('/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/Antarctic_GHF_uncertainty.xyz', 'FileType', 'text');
    xmu = martos_unc(:,1); ymu = martos_unc(:,2); zu = martos_unc(:,3);
    qa_map_scatter_source(xmu, ymu, zu, false, proj, 'UNC Martos σ (SOURCE)', fullfile(qa_outdir,'SRC_UNC_Martos.png'));
    [U_martos, keptMU, fracMU, nfinMU] = make_interpolant(xmu, ymu, zu);
    fprintf('[Martos σ] kept=%d/%.0f%% finite=%d\n', keptMU, 100*fracMU, nfinMU);
    coverage_check('Martos σ', xmu, ymu, Xgrid, Ygrid);

    UNC_Martos_interp = U_martos(Xgrid, Ygrid);
    qa_map(UNC_Martos_interp, Xgrid, Ygrid, 'UNC Martos (σ, mW m^{-2})', fullfile(qa_outdir,'map_UNC_Martos.png'));
    qa_hist(UNC_Martos_interp, 'UNC Martos (σ)', fullfile(qa_outdir,'hist_UNC_Martos.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Martos_interp_corr = GHF_Martos_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Martos_interp, GHF_Martos_interp_corr, roiMask, 'Martos'); 
        qa_map(GHF_Martos_interp_corr - GHF_Martos_interp, Xgrid, Ygrid, 'Martos: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Martos_dAbs.png'));
        qa_map(100*(GHF_Martos_interp_corr - GHF_Martos_interp)./GHF_Martos_interp, Xgrid, Ygrid, 'Martos: percent change (%)', fullfile(qa_outdir,'map_Martos_dPct.png'));
    end
end

%% ------------------ Shen (XYZ lon/lat) ------------------
if doModels.Shen
    shen = readmatrix('/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/shen.hf.v1.xyz', 'FileType', 'text');
    lonS = shen(:,1); latS = shen(:,2); zS = shen(:,3);
    qa_map_scatter_source(lonS, latS, zS, true, proj, 'GHF Shen (SOURCE)', fullfile(qa_outdir,'SRC_GHF_Shen.png'));
    [xpsS, ypsS] = projfwd(proj, latS, lonS);
    [F_shen, keptSh, fracSh, nfinSh] = make_interpolant(xpsS, ypsS, zS);
    fprintf('[Shen] kept=%d/%.0f%% finite=%d\n', keptSh, 100*fracSh, nfinSh);
    coverage_check('Shen mean', xpsS, ypsS, Xgrid, Ygrid);

    GHF_Shen_interp = F_shen(Xgrid, Ygrid);
    qa_map(GHF_Shen_interp, Xgrid, Ygrid, 'GHF Shen (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Shen.png'));
    qa_hist(GHF_Shen_interp, 'GHF Shen', fullfile(qa_outdir,'hist_GHF_Shen.png'));

    shen_std = readmatrix('/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/shen.unhf.v1.xyz', 'FileType','text');
    lonSu = shen_std(:,1); latSu = shen_std(:,2); zSu = shen_std(:,3);
    qa_map_scatter_source(lonSu, latSu, zSu, true, proj, 'UNC Shen σ (SOURCE)', fullfile(qa_outdir,'SRC_UNC_Shen.png'));
    [xpsSu, ypsSu] = projfwd(proj, latSu, lonSu);
    [STD_shen, keptShU, fracShU, nfinShU] = make_interpolant(xpsSu, ypsSu, zSu);
    fprintf('[Shen σ] kept=%d/%.0f%% finite=%d\n', keptShU, 100*fracShU, nfinShU);
    coverage_check('Shen σ', xpsSu, ypsSu, Xgrid, Ygrid);

    UNC_Shen_interp = STD_shen(Xgrid, Ygrid);
    qa_map(UNC_Shen_interp, Xgrid, Ygrid, 'UNC Shen (σ, mW m^{-2})', fullfile(qa_outdir,'map_UNC_Shen.png'));
    qa_hist(UNC_Shen_interp, 'UNC Shen (σ)', fullfile(qa_outdir,'hist_UNC_Shen.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Shen_interp_corr = GHF_Shen_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Shen_interp, GHF_Shen_interp_corr, roiMask, 'Shen'); 
        qa_map(GHF_Shen_interp_corr - GHF_Shen_interp, Xgrid, Ygrid, 'Shen: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Shen_dAbs.png'));
        qa_map(100*(GHF_Shen_interp_corr - GHF_Shen_interp)./GHF_Shen_interp, Xgrid, Ygrid, 'Shen: percent change (%)', fullfile(qa_outdir,'map_Shen_dPct.png'));
    end
end

%% ------------------ Losing (CSV lon/lat mean + min/max) ------------------
if doModels.Losing
    losing_tbl = readtable('/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/HF_Min_Max_MaxAbs-1.csv');
    lonL = losing_tbl{:,1}; latL = losing_tbl{:,2};
    zL   = losing_tbl{:,3}; zLmin = losing_tbl{:,4}; zLmax = losing_tbl{:,5};

    qa_map_scatter_source(lonL, latL, zL, true, proj, 'GHF Losing (SOURCE)',  fullfile(qa_outdir,'SRC_GHF_Losing.png'));
    qa_map_scatter_source(lonL, latL, zLmin, true, proj, 'BMIN Losing (SOURCE)', fullfile(qa_outdir,'SRC_BMIN_Losing.png'));
    qa_map_scatter_source(lonL, latL, zLmax, true, proj, 'BMAX Losing (SOURCE)', fullfile(qa_outdir,'SRC_BMAX_Losing.png'));

    [xpsL, ypsL] = projfwd(proj, latL, lonL);
    [F_L, keptL, fracL, nfinL] = make_interpolant(xpsL, ypsL, zL);
    [F_Lmin, keptLmin, fracLmin, nfinLmin] = make_interpolant(xpsL, ypsL, zLmin);
    [F_Lmax, keptLmax, fracLmax, nfinLmax] = make_interpolant(xpsL, ypsL, zLmax);
    fprintf('[Losing] mean kept=%d/%.0f%%; min kept=%d/%.0f%%; max kept=%d/%.0f%%\n', ...
        keptL, 100*fracL, keptLmin, 100*fracLmin, keptLmax, 100*fracLmax);
    coverage_check('Losing mean', xpsL, ypsL, Xgrid, Ygrid);

    GHF_Losing_interp  = F_L(Xgrid, Ygrid);
    BMIN_Losing_interp = F_Lmin(Xgrid, Ygrid);
    BMAX_Losing_interp = F_Lmax(Xgrid, Ygrid);
    qa_map(GHF_Losing_interp,  Xgrid, Ygrid, 'GHF Losing (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Losing.png'));
    qa_hist(GHF_Losing_interp, 'GHF Losing', fullfile(qa_outdir,'hist_GHF_Losing.png'));
    qa_map(BMIN_Losing_interp, Xgrid, Ygrid, 'Losing MIN (mW m^{-2})', fullfile(qa_outdir,'map_BMIN_Losing.png'));
    qa_map(BMAX_Losing_interp, Xgrid, Ygrid, 'Losing MAX (mW m^{-2})', fullfile(qa_outdir,'map_BMAX_Losing.png'));

    % --- Topo correction (mean only) ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Losing_interp_corr = GHF_Losing_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Losing_interp, GHF_Losing_interp_corr, roiMask, 'Losing'); 
        qa_map(GHF_Losing_interp_corr - GHF_Losing_interp, Xgrid, Ygrid, 'Losing: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Losing_dAbs.png'));
        qa_map(100*(GHF_Losing_interp_corr - GHF_Losing_interp)./GHF_Losing_interp, Xgrid, Ygrid, 'Losing: percent change (%)', fullfile(qa_outdir,'map_Losing_dPct.png'));
    end
end

%% ------------------ Haeger (TXT, EPSG:3031 X/Y) ------------------
if doModels.Haeger
    haeg_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/2022-002_Haeger-et-al_HFSurface.txt';

    % Columns: X, Y (EPSG:3031, km), HF, Std HF
    H = readmatrix(haeg_file);

    x_hg   = H(:,1) * 1000;
    y_hg   = H(:,2) * 1000;
    HF_hg  = H(:,3);
    SD_hg  = H(:,4);

    fprintf('[Haeger] N=%d points\n', numel(HF_hg));
    fprintf('[Haeger] bbox X=[%.0f, %.0f], Y=[%.0f, %.0f]\n', ...
        min(x_hg), max(x_hg), min(y_hg), max(y_hg));
    fprintf('[Target] bbox X=[%.0f, %.0f], Y=[%.0f, %.0f]\n', ...
        min(Xgrid(1,:)), max(Xgrid(1,:)), min(Ygrid(:,1)), max(Ygrid(:,1)));

    % Units: TXT has no metadata; assume already mW/m^2 and just log that
    HF_hg = to_mW_if_W(haeg_file, 'HF', HF_hg);
    SD_hg = to_mW_if_W(haeg_file, 'StdHF', SD_hg);

    qa_map_scatter_source(x_hg, y_hg, HF_hg, false, proj, ...
        'GHF Haeger (SOURCE)', fullfile(qa_outdir,'SRC_GHF_Haeger.png'));
    qa_map_scatter_source(x_hg, y_hg, SD_hg, false, proj, ...
        'UNC Haeger σ (SOURCE)', fullfile(qa_outdir,'SRC_UNC_Haeger.png'));

    [F_hg, keptHg, fracHg, nfinHg] = make_interpolant(x_hg, y_hg, HF_hg);
    [U_hg, keptHgU, fracHgU, nfinHgU] = make_interpolant(x_hg, y_hg, SD_hg);

    fprintf('[Haeger mean] kept=%d/%.1f%% finite=%d\n', keptHg, 100*fracHg, nfinHg);
    fprintf('[Haeger σ]   kept=%d/%.1f%% finite=%d\n', keptHgU, 100*fracHgU, nfinHgU);

    coverage_check('Haeger mean', x_hg, y_hg, Xgrid, Ygrid);

    GHF_Haeger_interp = F_hg(Xgrid, Ygrid);
    UNC_Haeger_interp = U_hg(Xgrid, Ygrid);

    qa_map(GHF_Haeger_interp, Xgrid, Ygrid, ...
        'GHF Haeger (mW m^{-2})', fullfile(qa_outdir,'map_GHF_Haeger.png'));
    qa_hist(GHF_Haeger_interp, 'GHF Haeger', ...
        fullfile(qa_outdir,'hist_GHF_Haeger.png'));

    qa_map(UNC_Haeger_interp, Xgrid, Ygrid, ...
        'UNC Haeger (σ, mW m^{-2})', fullfile(qa_outdir,'map_UNC_Haeger.png'));
    qa_hist(UNC_Haeger_interp, 'UNC Haeger (σ)', ...
        fullfile(qa_outdir,'hist_UNC_Haeger.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Haeger_interp_corr = GHF_Haeger_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Haeger_interp, GHF_Haeger_interp_corr, roiMask, 'Haeger'); 
        qa_map(GHF_Haeger_interp_corr - GHF_Haeger_interp, Xgrid, Ygrid, 'Haeger: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Haeger_dAbs.png'));
        qa_map(100*(GHF_Haeger_interp_corr - GHF_Haeger_interp)./GHF_Haeger_interp, Xgrid, Ygrid, 'Haeger: percent change (%)', fullfile(qa_outdir,'map_Haeger_dPct.png'));
    end
end

%% ------------------ Lucazeau (CSV lon/lat, HF + sHF) ------------------
if doModels.Lucazeau
    luc_file = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/HFgrid14.csv';

    luc_tbl = readtable(luc_file);
    lonLz = luc_tbl{:,1};
    latLz = luc_tbl{:,2};
    HF_Lz = luc_tbl{:,3};
    sHF_Lz = luc_tbl{:,4};

    qa_map_scatter_source(lonLz, latLz, HF_Lz, true, proj, ...
        'GHF Lucazeau (SOURCE)', fullfile(qa_outdir,'SRC_GHF_Lucazeau.png'));
    qa_map_scatter_source(lonLz, latLz, sHF_Lz, true, proj, ...
        'UNC Lucazeau σ (SOURCE)', fullfile(qa_outdir,'SRC_UNC_Lucazeau.png'));

    [xpsLz, ypsLz] = projfwd(proj, latLz, lonLz);
    [F_Lz, keptLz, fracLz, nfinLz]     = make_interpolant(xpsLz, ypsLz, HF_Lz);
    [U_Lz, keptLzU, fracLzU, nfinLzU]  = make_interpolant(xpsLz, ypsLz, sHF_Lz);

    fprintf('[Lucazeau] mean kept=%d/%.0f%% finite=%d | σ kept=%d/%.0f%% finite=%d\n', ...
        keptLz, 100*fracLz, nfinLz, keptLzU, 100*fracLzU, nfinLzU);
    coverage_check('Lucazeau mean', xpsLz, ypsLz, Xgrid, Ygrid);

    GHF_Lucazeau_interp = F_Lz(Xgrid, Ygrid);
    UNC_Lucazeau_interp = U_Lz(Xgrid, Ygrid);

    qa_map(GHF_Lucazeau_interp, Xgrid, Ygrid, 'GHF Lucazeau (mW m^{-2})', ...
        fullfile(qa_outdir,'map_GHF_Lucazeau.png'));
    qa_hist(GHF_Lucazeau_interp, 'GHF Lucazeau', ...
        fullfile(qa_outdir,'hist_GHF_Lucazeau.png'));

    qa_map(UNC_Lucazeau_interp, Xgrid, Ygrid, 'UNC Lucazeau (σ, mW m^{-2})', ...
        fullfile(qa_outdir,'map_UNC_Lucazeau.png'));
    qa_hist(UNC_Lucazeau_interp, 'UNC Lucazeau (σ)', ...
        fullfile(qa_outdir,'hist_UNC_Lucazeau.png'));

    % --- Topo correction ---
    if doTopo && ~isempty(Delta_topo)
        GHF_Lucazeau_interp_corr = GHF_Lucazeau_interp .* (1 + Delta_topo);
        topoStats(end+1) = topo_change_stats(GHF_Lucazeau_interp, GHF_Lucazeau_interp_corr, roiMask, 'Lucazeau'); 
        qa_map(GHF_Lucazeau_interp_corr - GHF_Lucazeau_interp, Xgrid, Ygrid, 'Lucazeau: corrected - original (mW m^{-2})', fullfile(qa_outdir,'map_Lucazeau_dAbs.png'));
        qa_map(100*(GHF_Lucazeau_interp_corr - GHF_Lucazeau_interp)./GHF_Lucazeau_interp, Xgrid, Ygrid, 'Lucazeau: percent change (%)', fullfile(qa_outdir,'map_Lucazeau_dPct.png'));
    end
end

%% ------------------ Save everything to datasets_for_gmin/ (+ GeoTIFFs) ------------------
if doModels.save
    outdir = '/disk/kea/WAIS/home/wais/users/mek/gmin_code/SPB_heterogeneity_kerr_2025/scripts/datasets/';
    if ~exist(outdir,'dir'), mkdir(outdir); end

    % Save topo stats/products first (so they exist even if no model toggles were on)
    if doTopo && saveTopoProducts && ~isempty(Delta_topo)
        save(fullfile(outdir,'Delta_Colgan_onTarget.mat'), 'Delta_topo', 'colgan_used');
        write_geotiff_epsg3031(fullfile(outdir,'Delta_Colgan_onTarget.tif'), Delta_topo, Xgrid, Ygrid);
    end

    if doTopo && ~isempty(topoStats)
        save(topo_stats_out, 'topoStats', 'colgan_used', 'colgan_nc');
        T = struct2table(topoStats);
        try writetable(T, topo_stats_csv); catch, end
        fprintf('[topo] wrote stats: %s\n', topo_stats_out);

        % Print to console too
        disp(T);
    end

    %% Means (MAT + GeoTIFF)
    if exist('GHF_Stal_interp','var')
        save(fullfile(outdir,'GHF_Stal_interp.mat'), 'GHF_Stal_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Stal_interp.tif'), ...
            GHF_Stal_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Stal_interp_corr','var')
        save(fullfile(outdir,'GHF_Stal_interp_corr.mat'), 'GHF_Stal_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Stal_interp_corr.tif'), ...
            GHF_Stal_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Hazzard_interp','var')
        save(fullfile(outdir,'GHF_Hazzard_interp.mat'), 'GHF_Hazzard_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Hazzard_interp.tif'), ...
            GHF_Hazzard_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Hazzard_interp_corr','var')
        save(fullfile(outdir,'GHF_Hazzard_interp_corr.mat'), 'GHF_Hazzard_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Hazzard_interp_corr.tif'), ...
            GHF_Hazzard_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_An_interp','var')
        save(fullfile(outdir,'GHF_An_interp.mat'), 'GHF_An_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_An_interp.tif'), ...
            GHF_An_interp, Xgrid, Ygrid);
    end
    if exist('GHF_An_interp_corr','var')
        save(fullfile(outdir,'GHF_An_interp_corr.mat'), 'GHF_An_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_An_interp_corr.tif'), ...
            GHF_An_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Martos_interp','var')
        save(fullfile(outdir,'GHF_Martos_interp.mat'), 'GHF_Martos_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Martos_interp.tif'), ...
            GHF_Martos_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Martos_interp_corr','var')
        save(fullfile(outdir,'GHF_Martos_interp_corr.mat'), 'GHF_Martos_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Martos_interp_corr.tif'), ...
            GHF_Martos_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Shen_interp','var')
        save(fullfile(outdir,'GHF_Shen_interp.mat'), 'GHF_Shen_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Shen_interp.tif'), ...
            GHF_Shen_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Shen_interp_corr','var')
        save(fullfile(outdir,'GHF_Shen_interp_corr.mat'), 'GHF_Shen_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Shen_interp_corr.tif'), ...
            GHF_Shen_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Losing_interp','var')
        save(fullfile(outdir,'GHF_Losing_interp.mat'), 'GHF_Losing_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Losing_interp.tif'), ...
            GHF_Losing_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Losing_interp_corr','var')
        save(fullfile(outdir,'GHF_Losing_interp_corr.mat'), 'GHF_Losing_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Losing_interp_corr.tif'), ...
            GHF_Losing_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_FoxMaule_interp','var')
        save(fullfile(outdir,'GHF_FoxMaule_interp.mat'), 'GHF_FoxMaule_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_FoxMaule_interp.tif'), ...
            GHF_FoxMaule_interp, Xgrid, Ygrid);
    end
    if exist('GHF_FoxMaule_interp_corr','var')
        save(fullfile(outdir,'GHF_FoxMaule_interp_corr.mat'), 'GHF_FoxMaule_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_FoxMaule_interp_corr.tif'), ...
            GHF_FoxMaule_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Haeger_interp','var')
        save(fullfile(outdir,'GHF_Haeger_interp.mat'), 'GHF_Haeger_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Haeger_interp.tif'), ...
            GHF_Haeger_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Haeger_interp_corr','var')
        save(fullfile(outdir,'GHF_Haeger_interp_corr.mat'), 'GHF_Haeger_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Haeger_interp_corr.tif'), ...
            GHF_Haeger_interp_corr, Xgrid, Ygrid);
    end

    if exist('GHF_Lucazeau_interp','var')
        save(fullfile(outdir,'GHF_Lucazeau_interp.mat'), 'GHF_Lucazeau_interp');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Lucazeau_interp.tif'), ...
            GHF_Lucazeau_interp, Xgrid, Ygrid);
    end
    if exist('GHF_Lucazeau_interp_corr','var')
        save(fullfile(outdir,'GHF_Lucazeau_interp_corr.mat'), 'GHF_Lucazeau_interp_corr');
        write_geotiff_epsg3031(fullfile(outdir,'GHF_Lucazeau_interp_corr.tif'), ...
            GHF_Lucazeau_interp_corr, Xgrid, Ygrid);
    end

    %% Uncertainties / bounds (MAT + GeoTIFF)
    if exist('UNC_Stal_interp','var')
        save(fullfile(outdir,'UNC_Stal_interp.mat'), 'UNC_Stal_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Stal_interp.tif'), ...
            UNC_Stal_interp, Xgrid, Ygrid);
    end

    if exist('UNC_Hazzard_interp','var')
        save(fullfile(outdir,'UNC_Hazzard_interp.mat'), 'UNC_Hazzard_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Hazzard_interp.tif'), ...
            UNC_Hazzard_interp, Xgrid, Ygrid);
    end

    if exist('UNC_Martos_interp','var')
        save(fullfile(outdir,'UNC_Martos_interp.mat'), 'UNC_Martos_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Martos_interp.tif'), ...
            UNC_Martos_interp, Xgrid, Ygrid);
    end

    if exist('UNC_Shen_interp','var')
        save(fullfile(outdir,'UNC_Shen_interp.mat'), 'UNC_Shen_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Shen_interp.tif'), ...
            UNC_Shen_interp, Xgrid, Ygrid);
    end

    if exist('BMIN_Losing_interp','var')
        save(fullfile(outdir,'BMIN_Losing_interp.mat'), 'BMIN_Losing_interp');
        write_geotiff_epsg3031(fullfile(outdir,'BMIN_Losing_interp.tif'), ...
            BMIN_Losing_interp, Xgrid, Ygrid);
    end

    if exist('BMAX_Losing_interp','var')
        save(fullfile(outdir,'BMAX_Losing_interp.mat'), 'BMAX_Losing_interp');
        write_geotiff_epsg3031(fullfile(outdir,'BMAX_Losing_interp.tif'), ...
            BMAX_Losing_interp, Xgrid, Ygrid);
    end

    if exist('UNC_Haeger_interp','var')
        save(fullfile(outdir,'UNC_Haeger_interp.mat'), 'UNC_Haeger_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Haeger_interp.tif'), ...
            UNC_Haeger_interp, Xgrid, Ygrid);
    end

    if exist('UNC_Lucazeau_interp','var')
        save(fullfile(outdir,'UNC_Lucazeau_interp.mat'), 'UNC_Lucazeau_interp');
        write_geotiff_epsg3031(fullfile(outdir,'UNC_Lucazeau_interp.tif'), ...
            UNC_Lucazeau_interp, Xgrid, Ygrid);
    end

    fprintf('All interpolated grids saved as MAT + GeoTIFF in %s\n', outdir);
    fprintf('All QA maps (source + target) saved in %s\n', qa_outdir);
end

function write_geotiff_epsg3031(filename, Z, Xgrid, Ygrid, nodataVal)
% WRITE_GEOTIFF_EPSG3031  Save a grid on Xgrid/Ygrid as a GeoTIFF (EPSG:3031).
%
%   - Assumes Xgrid, Ygrid are cell centers in meters (EPSG:3031).
%   - Expands world limits by half a cell to get cell edges.
%   - Replaces non-finite values with nodataVal (default -9999).

    if nargin < 5 || isempty(nodataVal)
        nodataVal = -9999;
    end

    Zout = Z;
    bad = ~isfinite(Zout);
    Zout(bad) = nodataVal;

    xv = Xgrid(1, :);
    yv = Ygrid(:, 1);

    dx = median(diff(xv), 'omitnan');
    dy = median(diff(yv), 'omitnan');

    xmin = min(xv) - dx/2;
    xmax = max(xv) + dx/2;
    ymin = min(yv) - dy/2;
    ymax = max(yv) + dy/2;

    R = maprefcells([xmin xmax], [ymin ymax], size(Zout));

    try
        R.RowsStartFrom = 'south';
    catch
    end

    geotiffwrite(filename, Zout, R, 'CoordRefSysCode', 3031);
    fprintf('[GeoTIFF] wrote %s (EPSG:3031, nodata=%g)\n', filename, nodataVal);
end
